/*
 * =====================================================================================
 *
 *       Filename:  SamToM4.cpp
 *
 *    Description:  Convert a sam file to a blasr m4 file.
 *
 *        Version:  1.0
 *        Created:  04/03/2013 01:19:43 PM
 *       Revision:  none
 *       Compiler:  gcc
 *
 *         Author:  Yuan Li (yli), yli@pacificbiosciences.com
 *        Company:  Pacific Biosciences
 *
 * =====================================================================================
 */
#include <iostream>
#include "FASTASequence.h"
#include "FASTAReader.h"
#include "CommandLineParser.h"
#include "utils/ChangeListID.h"
#include "algorithms/alignment/ScoreMatrices.h"
#include "algorithms/alignment/AlignmentUtils.h"
#include "algorithms/alignment/readers/sam/SAMReader.h"
#include "algorithms/alignment/printers/IntervalAlignmentPrinter.h"
#include "datastructures/alignment/AlignmentCandidate.h"
#include "datastructures/alignmentset/SAMToAlignmentCandidateAdapter.h"

char VERSION[] = "v0.1.0";
char PERFORCE_VERSION_STRING[] = "";
 
int main(int argc, char* argv[]) {
    string samFileName, refFileName, outFileName;
    bool printHeader = false;
    bool parseSmrtTitle = false;

    CommandLineParser clp;
    clp.RegisterStringOption("file.sam",        &samFileName,
                             "Input SAM file, which is produced by blasr.");
    clp.RegisterStringOption("reference.fasta", &refFileName,
                             "Reference used to generate file.sam.");
    clp.RegisterStringOption("out.m4",         &outFileName,
                             "Output in blasr M4 format.");
    clp.RegisterPreviousFlagsAsHidden();

    clp.RegisterFlagOption("header",            &printHeader,
                           "Print M4 header.");

    clp.SetExamples("Parse a SAM file generated by blasr to M4 format.\n"
            "samtom4 file.sam reference.fasta out.m4");

    clp.ParseCommandLine(argc, argv);

    ostream * outFilePtr = &cout;
	ofstream outFileStrm;
	if (outFileName != "") {
		CrucialOpen(outFileName, outFileStrm, std::ios::out);
		outFilePtr = &outFileStrm;
	}

    SAMReader<SAMFullReferenceSequence, SAMReadGroup, SAMAlignment> samReader;
    FASTAReader fastaReader;

    //
    // Initialize samReader and fastaReader.
    //
    samReader.Initialize(samFileName);
    fastaReader.Initialize(refFileName);

    //
    // Configure the file log.
    //
    string command;
    CommandLineParser::CommandLineToString(argc, argv, command);
    string program = "samtom4";
    string versionString = VERSION;
    AppendPerforceChangelist(PERFORCE_VERSION_STRING, versionString);

    //
    // Read necessary input.
    //
    vector<FASTASequence> references;
    fastaReader.ReadAllSequences(references);

    AlignmentSet<SAMFullReferenceSequence, SAMReadGroup, SAMAlignment> alignmentSet;
    samReader.ReadHeader(alignmentSet); 

    //
    // The order of references in vector<FASTASequence> references and
    // AlignmentSet<, , >alignmentSet.references can be different.
    // Rearrange alignmentSet.references such that it is ordered in
    // exactly the same way as vector<FASTASequence> references.
    //
    alignmentSet.RearrangeReferences(references);

    // Map reference name obtained from SAM file to indices
    map<string, int> refNameToIndex;
    for (int i = 0; i < references.size(); i++) {
        string refName = alignmentSet.references[i].GetSequenceName();
        refNameToIndex[refName] = i;
    }

    //
    // Store the alignments.
    //
    SAMAlignment samAlignment;
    int alignIndex = 0; 

    //
    // For 150K, each chip produces about 300M sequences 
    // (not including quality values and etc.).
    // Let's assume that the sam file and reference data can 
    // fit in the memory. 
    // Need to scale for larger sequal data in the future.
    //
    if (printHeader)
        IntervalAlignmentPrinter::PrintHeader(*outFilePtr);

    // The socre matrix does not matter because we will use the 
    // aligner's score from SAM file anyway.
    int scoreMatrix[5][5];

    while (samReader.GetNextAlignment(samAlignment)) {
        if (samAlignment.rName == "*") {
            continue;
        }

        // The padding character 'P' is not supported
        if (samAlignment.cigar.find('P') != string::npos) {
            cout << "WARNING. Could not process sam record with 'P' in its cigar string."
                 << endl;
            continue;
        }

        vector<AlignmentCandidate<> > convertedAlignments;

        //
        // Keep reference as forward.
        // So if IsReverseComplement(sam.flag)==true, then qStrand is reverse
        // and tStrand is forward.
        //
        bool keepRefAsForward = false;

        SAMAlignmentsToCandidates(samAlignment, references, refNameToIndex,
                                  convertedAlignments, parseSmrtTitle, 
                                  keepRefAsForward);

        if (convertedAlignments.size() > 1) {
            cout << "WARNING. Ignore an alignment which has multiple segments." << endl;
            continue;
        }

        //all alignments are unique single-ended alignments.
        for (int i = 0; i < 1; i++) {
            AlignmentCandidate<> & alignment = convertedAlignments[i];

            ComputeAlignmentStats(alignment, alignment.qAlignedSeq.seq, 
                                  alignment.tAlignedSeq.seq, scoreMatrix,
                                  5, 5);

            // Use aligner's score from SAM file anyway.
            alignment.score = samAlignment.as;
            alignment.mapQV = samAlignment.mapQV;

            // Since SAM only has the aligned sequence, many info of the 
            // original query (e.g. the full length) is missing. 
            // Overwrite alignment.qLength (which is length of the query
            // in the SAM alignment) with xq (which is the length of the 
            // original query sequence saved by blasr) right before printing 
            // the output so that one can reconstruct a blasr m4 record from 
            // a blasr sam alignment.
            if (samAlignment.xq!=0)
                alignment.qLength = samAlignment.xq;

            IntervalAlignmentPrinter::PrintFromSAM(alignment, *outFilePtr);

            alignment.FreeSubsequences();
        }
        ++alignIndex;
    }

	if (outFileName != "") {
		outFileStrm.close();
	}
    return 0;
}
